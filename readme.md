* 线程之间的通信（thread signal）
	* 线程通信的目的是为了能够让线程之间相互发送信号
	* java.lang.Object提供的wait()、notify()、notifyAll()
		* Java提供了一种内联机制可以让线程在等待信号时进入非运行状态。
			当一个线程调用任何对象上的wait()方法时便会进入非运行状态，
			直到另一个线程调用同一个对象上的notify()或notifyAll()方法。
			为了能够调用一个对象的wait()、notify()方法，调用线程必须先获得这个对象的锁。
			因为线程只有在同步块中才会占用对象的锁，所以线程必须在同步块中调用wait()、notify()方法
* 线程之间的同步
	* 同步是指程序用于控制不同线程之间操作发生相对顺序的机制
	* 在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行
	* 在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的
	* 线程同步（7种同步方式）
		* 同步方法( 即有synchronized关键字修饰的方法)
		* 同步代码块 (即有synchronized关键字修饰的语句块)
		* 使用特殊域变量(volatile)实现线程同步
			* volatile关键字为域变量的访问提供了一种免锁机制， 
			* 使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新， 
			* 因此每次使用该域就要重新计算，而不是使用寄存器中的值 
			* volatile不会提供任何原子操作，它也不能用来修饰final类型的变量
		* 使用重入锁实现线程同步
			* ReentrantLock类是可重入、互斥、实现了Lock接口的锁
		* 使用局部变量实现线程同步
			* 如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本， 副本之间相互独立，
				这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响
			* ThreadLocal 类的常用方法:
				* ThreadLocal() : 创建一个线程本地变量 
			    * get() : 返回此线程局部变量的当前线程副本中的值 
			    * initialValue() : 返回此线程局部变量的当前线程的"初始值" 
			    * set(T value) : 将此线程局部变量的当前线程副本中的值设置为value
		* 使用阻塞队列实现线程同步(BlockingQueue)
		* 使用原子变量实现线程同步
		
#### 推荐文章 https://www.cnblogs.com/XHJT/p/3897440.html